<!DOCTYPE html>
<html lang="en-us">
    <head>
         
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Rendering the Moana Island Scene Part 1: Implementing the Disney BSDF</title>
        
        <style>

    html body {
        font-family: 'Cambria', sans-serif;
        background-color: white;
    }

</style>


<link rel="stylesheet" href="https://schuttejoe.github.io/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Cambria">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai-sublime.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 


    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>

    

    <script>hljs.initHighlightingOnLoad();</script>







<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.37" />
    </head>

    
    
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
    
    <script src="https://schuttejoe.github.io/js/mathjaxsetup.js"></script>

    <body>
         
        <nav class="navbar navbar-default navbar-fixed-top">

            <div class="container">

                
                    <ul class="nav navbar-nav">
                        
                            <li><a href="/">Home</a></li>
                        
                            <li><a href="/post/">Blog</a></li>
                        
                            <li><a href="/project/">Projects</a></li>
                        
                    </ul>
                

                
                    <ul class="nav navbar-nav navbar-right">
                        
                            <li class="navbar-icon"><a href="mailto:schutte.joe@gmail.com"><i class="fa fa-envelope-o"></i></a></li>
                        
                            <li class="navbar-icon"><a href="https://twitter.com/schuttejoe/"><i class="fa fa-twitter"></i></a></li>
                        
                            <li class="navbar-icon"><a href="https://github.com/schuttejoe/"><i class="fa fa-github"></i></a></li>
                        
                            <li class="navbar-icon"><a href="https://www.linkedin.com/in/joe-schutte-32540212/"><i class="fa fa-linkedin"></i></a></li>
                        
                    </ul>
                

            </div>

        </nav>


<main>

    <a href="https://schuttejoe.github.io/img/Posts/DisneyBsdf/Preview.png"><img src="https://schuttejoe.github.io/img/Posts/DisneyBsdf/Preview.png" width="400" height="225"></a>
    <h3>Rendering the Moana Island Scene Part 1: Implementing the Disney BSDF</h3>
    <h5>August 10, 2018</h5>
    <hr>

    <br> <div class="text-justify">

<p>$\newcommand{\i}{\textit{i}}$
$\newcommand{\o}{\textit{o}}$
$\newcommand{\n}{\textit{n}}$
$\newcommand{\h}{\textit{h}}$
$\newcommand{\v}{\textit{v}}$
$\newcommand{\x}{\textit{x}}$
$\newcommand{\y}{\textit{y}}$
$\newcommand{\ht}{\textit{h}_t}$</p>

<hr />

<h2 id="intro">Intro</h2>

<p>The Disney BRDF was introduced by Brent Burley as part of the <a href="http://blog.selfshadow.com/publications/s2012-shading-course/">SIGGRAPH 2012 Physically Based Shading course</a> and then extended to a BSDF with integrated subsurface scattering for the <a href="http://blog.selfshadow.com/publications/s2015-shading-course/">SIGGRAPH 2015 Physically Based Shading course</a>. While the model is not strictly physically based it was designed with physically based principles in mind and each of the terms included was done so to fit the model to materials in the MERL 100 database. More importantly, each term was carefully chosen and parameterized to be easy for artists to use and so that blending multiple layers together would give intuitive results. I believe it is these later traits that have made the Disney BSDF to be so successful.</p>

<p>The materials in the Moana Island scene are all one of two types: &ldquo;solid&rdquo; or &ldquo;thin&rdquo;. Both material types generally behave the same with the exception being when transmission is involved. For thin materials there is no internal surface so subsurface scattering is approximated with Hanrahan-Krueger diffuse. Additionally, since there is also no volume to refract into and later out of both the enter and exit events are modeled simultaneously at the same point. The most common example of this material type in the Island scene is for leaves and other foliage modeled without an interior volume. It would then make sense to guess that the solid material type is for objects that are modeled with an interior volume.</p>

<p>The title of my blog (Rendering Equations) wouldn&rsquo;t be a bad pun for giving you a bunch of equations if I didn&rsquo;t include a whole bunch of equations in each post. So next I&rsquo;ll describe each individual lobe of the Disney BSDF and then I&rsquo;ll wrap up by discussing sampling of each lobe.</p>

<hr />

<h2 id="sheen">Sheen</h2>

<p>The sheen lobe is probably the simplest of all of the terms so we&rsquo;ll start here. It is a standalone lobe that is added to the others based on a $\textit{sheen}$ parameter with its color varying between white and the a tinted color depending on the $\textit{sheenTint}$ parameter. It&rsquo;s purpose is to model light at grazing angles on a surface so it will mostly be used for retro-reflection seen in cloth or on rougher surfaces to add back in energy lost due to a geometry term that only models single-scattering. I wouldn&rsquo;t be surprised to see this term be replaced with something like <a href="https://eheitzresearch.wordpress.com/240-2/">Multiple-Scattering Microfacet BSDFs with the Smith Model</a> or <a href="http://blog.selfshadow.com/2018/06/04/multi-faceted-part-2/">A Multi-Faceted Exploration (Part 2)</a> in Disney&rsquo;s future iterations though that would necessitate an alternate solution for retro-reflection where their diffuse term is insufficient.</p>

<p>While I don&rsquo;t recall seeing it mentioned anywhere in the notes, in the <a href="https://github.com/wdas/brdf">Disney BRDF Explorer</a> they extract the hue and saturation from the base color and use that for the sheen lobe&rsquo;s tint color rather than using the base color directly. This is done by calculating the luminance using approximate, linear-space CIE luminance weights and then normalizing:</p>

<pre><code>static float3 CalculateTint(float3 baseColor)
{
    // -- The color tint is never mentioned in the SIGGRAPH presentations as far as I recall but it was done in
    // --  the BRDF Explorer so I'll replicate that here.
    float luminance = Dot(float3(0.3f, 0.6f, 1.0f), baseColor);
    return (luminance &gt; 0.0f) ? baseColor * (1.0f / luminance) : float3::One_;
}
</code></pre>

<p>With that we can then calculate the intensity of the sheen lobe:
$$f(\textit{sheen}, \theta_d) = \textit{sheen} * ((1 - \textit{sheenTint}) + \textit{sheenTint} * \textit{tint}) * (1 - \cos\theta_d)^5$$</p>

<pre><code>static float3 EvaluateSheen(const SurfaceParameters&amp; surface, const float3&amp; wo, const float3&amp; wm, const float3&amp; wi)
{
    if(surface.sheen &lt;= 0.0f) {
        return float3::Zero_;
    }

    float dotHL = Dot(wm, wi);
    float3 tint = CalculateTint(surface.baseColor);
    return surface.sheen * Lerp(float3(1.0f), tint, surface.sheenTint) * Fresnel::SchlickWeight(dotHL);
}
</code></pre>

<hr />

<h2 id="clearcoat">Clearcoat</h2>

<p>The Clearcoat lobe is another additive lobe that is controlled by a $\textit{clearcoat}$ parameter for its intensity and a $\textit{clearcoatGloss}$ parameter for its shape. This lobe is a bit more complicated and models a full BRDF but most of its terms are fixed to keep this lobe as a simple, artist-friendly way to model, well, a clear&hellip; coating on top of a material. It&rsquo;s pretty well named.</p>

<p>The distribution term used for the clearcoat layer is a fixed form of a BRDF created by Burley and called Generalized Trowbridge-Reitz. Here is its normalized form with a fixed gamma of one used for clearcoat via Burley&rsquo;s course notes:</p>

<p>$$D_{GTR_1}(x) = \frac{\alpha^2 - 1}{\pi\log(\alpha^2)} \frac{1}{1 + (\alpha^2 - 1)\cos^2\theta_h}$$</p>

<p>The Fresnel term uses the Schlick approximation with a fixed index of refraction of 1.5 to be representative of polyurethane. This evaluates to $F_0 = 0.04$. If you want details on how that is calculated SÃ©bastien Lagarde <a href="https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/">wrote about the Fresnel equation in a ton of detail.</a></p>

<p>$$f_{Schlick} = F_0 + (1 - F_0)(1 - \cos\theta_h)^5$$</p>

<p>The masking-shadowing term used was the separable form of Smith for GGX with a fixed roughness of 0.25. While the term is not the correct match for the distribution of normals as of the 2014 addendum to the 2012 course notes it looks like they were happy with the look and have not changed it.</p>

<p>$$G(\theta, \alpha) = \frac{1}{\cos\theta + \sqrt{\alpha^2 + \cos\theta - \alpha^2\cos^2\theta}}$$
$$G(\theta_l, \theta_v) = G(\theta_l, 0.25) * G(\theta_v, 0.25)$$</p>

<pre><code>//===================================================================================================================
static float GTR1(float absDotHL, float a)
{
    if(a &gt;= 1) {
        return InvPi_;
    }

    float a2 = a * a;
    return (a2 - 1.0f) / (Pi_ * Log2(a2) * (1.0f + (a2 - 1.0f) * absDotHL * absDotHL));
}

//===================================================================================================================
float SeparableSmithGGXG1(const float3&amp; w, float a)
{
    float a2 = a * a;
    float absDotNV = AbsCosTheta(w);

    return 2.0f / (1.0f + Math::Sqrtf(a2 + (1 - a2) * absDotNV * absDotNV));
}

//===================================================================================================================
static float EvaluateDisneyClearcoat(float clearcoat, float alpha, const float3&amp; wo, const float3&amp; wm,
                                     const float3&amp; wi, float&amp; fPdfW, float&amp; rPdfW)
{
    if(clearcoat &lt;= 0.0f) {
        return 0.0f;
    }

    float absDotNH = AbsCosTheta(wm);
    float absDotNL = AbsCosTheta(wi);
    float absDotNV = AbsCosTheta(wo);
    float dotHL = Dot(wm, wi);

    float d = GTR1(absDotNH, Lerp(0.1f, 0.001f, alpha));
    float f = Fresnel::Schlick(0.04f, dotHL);
    float gl = Bsdf::SeparableSmithGGXG1(wi, 0.25f);
    float gv = Bsdf::SeparableSmithGGXG1(wo, 0.25f);

    fPdfW = d / (4.0f * absDotNL);
    rPdfW = d / (4.0f * absDotNV);

    return 0.25f * clearcoat * d * f * gl * gv;
}
</code></pre>

<hr />

<h2 id="specular-brdf">Specular BRDF</h2>

<p>The specular BRDF is the traditional Cook-Torrance microfacet BRDF that uses Anisotropic GGX (aka GTR2) with a Smith masking-shadowing function. Burley calculated the anisotropic weights $\alpha_x$ and $\alpha_y$ with:</p>

<p>$$\textit{aspect} = \sqrt{1 - 0.9 * \textit{anisotropic}}$$
$$\alpha_x = \textit{roughness}^2 / \textit{aspect}$$
$$\alpha_y = \textit{roughness}^2 * \textit{aspect}$$</p>

<p>The anisotropic distribution of normals is:</p>

<p>$$D_{GTR_2aniso} = \frac{1}{\pi \alpha_x \alpha_y} \frac{1}{(\frac{(\h \cdot \x)^2}{\alpha_x^2} + \frac{(\h \cdot \y)^2}{\alpha_y^2} + (\h \cdot \n)^2)^2}$$</p>

<p>Via the 2014 addendum to the course notes we know that Disney changed their geometry term to match the anisotropic Smith GGX term derived by Heitz in <a href="http://jcgt.org/published/0003/02/03/"><strong>Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs</strong></a>.</p>

<p>$$G1_{GTR_2aniso} = \frac{1}{1 + \Lambda(\wo)}$$
$$\Lambda(\wo) = \frac{-1 + \sqrt{1 + \frac{1}{a^2}}}{2}$$
$$a = \frac{1}{\tan\theta_o\sqrt{\cos^2\phi_o\alpha_x^2 + \sin^2\phi_o\alpha_y^2}}$$</p>

<p>In the code you can see I call the DisneyFresnel function to calculate the Fresnel term. I&rsquo;ll talk more about that later.</p>

<pre><code>//===================================================================================================================
float GgxAnisotropicD(const float3&amp; wm, float ax, float ay)
{
    float dotHX2 = Square(wm.x);
    float dotHY2 = Square(wm.z);
    float cos2Theta = Cos2Theta(wm);
    float ax2 = Square(ax);
    float ay2 = Square(ay);

    return 1.0f / (Math::Pi_ * ax * ay * Square(dotHX2 / ax2 + dotHY2 / ay2 + cos2Theta));
}

//===================================================================================================================
float SeparableSmithGGXG1(const float3&amp; w, const float3&amp; wm, float ax, float ay)
{
    float dotHW = Dot(w, wm);
    if (dotHW &lt;= 0.0f) {
        return 0.0f;
    }

    float absTanTheta = Absf(TanTheta(w));
    if(IsInf(absTanTheta)) {
        return 0.0f;
    }

    float a = Sqrtf(Cos2Phi(w) * ax * ax + Sin2Phi(w) * ay * ay);
    float a2Tan2Theta = Square(a * absTanTheta);

    float lambda = 0.5f * (-1.0f + Sqrtf(1.0f + a2Tan2Theta));
    return 1.0f / (1.0f + lambda);
}

//===================================================================================================================
static float3 EvaluateDisneyBRDF(const SurfaceParameters&amp; surface, const float3&amp; wo, const float3&amp; wm,
                                 const float3&amp; wi, float&amp; fPdf, float&amp; rPdf)
{
    fPdf = 0.0f;
    rPdf = 0.0f;

    float dotNL = CosTheta(wi);
    float dotNV = CosTheta(wo);
    if(dotNL &lt;= 0.0f || dotNV &lt;= 0.0f) {
        return float3::Zero_;
    }

    float ax, ay;
    CalculateAnisotropicParams(surface.roughness, surface.anisotropic, ax, ay);

    float d = Bsdf::GgxAnisotropicD(wm, ax, ay);
    float gl = Bsdf::SeparableSmithGGXG1(wi, wm, ax, ay);
    float gv = Bsdf::SeparableSmithGGXG1(wo, wm, ax, ay);

    float3 f = DisneyFresnel(surface, wo, wm, wi);

    Bsdf::GgxVndfAnisotropicPdf(wi, wm, wo, ax, ay, fPdf, rPdf);
    fPdf *= (1.0f / (4 * AbsDot(wo, wm)));
    rPdf *= (1.0f / (4 * AbsDot(wi, wm)));

    return d * gl * gv * f / (4.0f * dotNL * dotNV);
}
</code></pre>

<p>You&rsquo;ll notice that in SeparableSmithGGXG1 I use a lot of trig functions (ex: Sin2Phi, TanTheta). I&rsquo;m using the unoptimized implementation described in <a href="http://jcgt.org/published/0003/02/03/">Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs</a>. There exists an optimized form of this in the Disney BRDF explorer but that goes to infinity under some circumstances so I&rsquo;m not convinced it&rsquo;s correct.</p>

<hr />

<h2 id="specular-bsdf">Specular BSDF</h2>

<p>The specular BSDF is an extension of the specular BRDF to handle refraction. Since I haven&rsquo;t discussed refraction in this blog I&rsquo;ll note that the microfacet form for it is given by:</p>

<p>$$f_t(\i,\o,\n) = \frac{|\i \cdot \ht|}{|\i \cdot \n|}\frac{|o \cdot \ht|}{|\o \cdot \n|}\frac{\eta^2}{(\i \cdot \ht + \eta\o\cdot\ht)^2}\frac{1}{\eta^2} (1 - F(\i, \ht)) G(\i,\o,\ht) D(\ht)$$</p>

<p>with $\ht = -\frac{\i + \eta\o}{||i + \eta\o||}$ and $\eta = \frac{\eta_i}{\eta_o}$ being the relative index of refraction.</p>

<p>Other than that, the BSDF uses the same distribution and geometry terms as the BRDF. They model the full dielectric Fresnel equation for this since they ran into issues where the relative IOR was close to 1. My implementation for Fresnel::Dielectric is just copied from PBRT so I&rsquo;ll link that <a href="https://github.com/mmp/pbrt-v3/blob/master/src/core/reflection.cpp">here</a> rather than inline the code.</p>

<p>Finally, when using the thin material model we use the square root of the base color to model both the entrance and the exit event at the same time. We also adjust the anisotropic roughness parameters based on the index of refraction which is handled outside of EvaluateDisneySpecTransmission.</p>

<pre><code>//===================================================================================================================
static float ThinTransmissionRoughness(float ior, float roughness)
{
    // -- Disney scales by (.65 * eta - .35) based on figure 15 of the 2015 PBR course notes. Based on their figure
    // -- the results match a geometrically thin solid fairly well.
    return Saturate((0.65f * ior - 0.35f) * roughness);
}

//===================================================================================================================
static float3 EvaluateDisneySpecTransmission(const SurfaceParameters&amp; surface, const float3&amp; wo, const float3&amp; wm,
                                             const float3&amp; wi, float ax, float ay, bool thin)
{
    float relativeIor = surface.relativeIOR;
    float n2 = relativeIor * relativeIor;

    float absDotNL = AbsCosTheta(wi);
    float absDotNV = AbsCosTheta(wo);
    float dotHL = Dot(wm, wi);
    float dotHV = Dot(wm, wo);
    float absDotHL = Absf(dotHL);
    float absDotHV = Absf(dotHV);

    float d = Bsdf::GgxAnisotropicD(wm, ax, ay);
    float gl = Bsdf::SeparableSmithGGXG1(wi, wm, ax, ay);
    float gv = Bsdf::SeparableSmithGGXG1(wo, wm, ax, ay);

    float f = Fresnel::Dielectric(dotHV, 1.0f, 1.0f / surface.relativeIOR);

    float3 color;
    if(thin)
        color = Sqrt(surface.baseColor);
    else
        color = surface.baseColor;
    
    // Note that we are intentionally leaving out the 1/n2 spreading factor since for VCM we will be evaluating
    // particles with this. That means we'll need to model the air-[other medium] transmission if we ever place
    // the camera inside a non-air medium.
    float c = (absDotHL * absDotHV) / (absDotNL * absDotNV);
    float t = (n2 / Square(dotHL + relativeIor * dotHV));
    return color * c * t * (1.0f - f) * gl * gv * d;
}
</code></pre>

<hr />

<h2 id="diffuse-brdf">Diffuse BRDF</h2>

<p>The diffuse lobe is a bit more complicated than the typical Lambert diffuse model. Burley did a lot here to fit materials to the MERL database. Their model includes both a diffuse Fresnel factor as well as a term for diffuse retro-reflection. Additionally, the non-directional portion of the model is split out such that it can be replaced with a subsurface model using either diffusion or volumetric scattering. The whole diffuse lobe is given as:</p>

<p>$$f_d = f_{Lambert} (1 - 0.5F_L)(1 - 0.5F_V) + f_{retro-reflection}$$</p>

<p>with:</p>

<p>$$f_{retro-reflection} = \frac{baseColor}{\pi} R_R(F_L + F_V + F_LF_V(R_R - 1))$$
$$F_L = (1 - \cos\theta_l)^5$$
$$F_v = (1 - \cos\theta_v)^5$$
$$R_R = 2 * \textit{roughness} * \cos^2(\theta_d)$$</p>

<p>and $f_{Lambert}$ being either a simple Lambert term:</p>

<p>$$f_{Lambert} = \frac{\textit{baseColor}}{\pi}$$</p>

<p>or, when we&rsquo;re evaluating a thin surface, it will be a blend between Lambert and the Hanrahan Krueger diffuse model based on the <em>flatness</em> parameter.</p>

<pre><code>//===================================================================================================================
static float EvaluateDisneyDiffuse(const SurfaceParameters&amp; surface, const float3&amp; wo, const float3&amp; wm,
                                   const float3&amp; wi, bool thin)
{
    float dotNL = AbsCosTheta(wi);
    float dotNV = AbsCosTheta(wo);

    float fl = Fresnel::SchlickWeight(dotNL);
    float fv = Fresnel::SchlickWeight(dotNV);

    float hanrahanKrueger = 0.0f;

    if(thin &amp;&amp; surface.flatness &gt; 0.0f) {
        float roughness = surface.roughness * surface.roughness;

        float dotHL = Dot(wm, wi);
        float fss90 = dotHL * dotHL * roughness;
        float fss = Lerp(1.0f, fss90, fl) * Lerp(1.0f, fss90, fv);

        float ss = 1.25f * (fss * (1.0f / (dotNL + dotNV) - 0.5f) + 0.5f);
        hanrahanKrueger = ss;
    }

    float lambert = 1.0f;
    float retro = EvaluateDisneyRetroDiffuse(surface, wo, wm, wi);
    float subsurfaceApprox = Lerp(lambert, hanrahanKrueger, thin ? surface.flatness : 0.0f);

    return InvPi_ * (retro + subsurfaceApprox * (1.0f - 0.5f * fl) * (1.0f - 0.5f * fv));
}
</code></pre>

<hr />

<h2 id="bringing-it-all-together">Bringing it all together</h2>

<p>Now let&rsquo;s describe how these terms are all brought together. The clearcoat lobe and the sheen lobe are both additive. The rest of the terms are described with this diagram from the 2015 PBR paper.</p>

<p><center><img src="/img/Posts/DisneyBsdf/Blending.png" alt="" /></center></p>

<p>In this diagram you can see that we blend between the specular transmission lobe and the dielectric BRDF based on the <em>specTrans</em> parameter and then we blend that with the metallic lobe based on the <em>metallic</em> parameter. But what are the metallic and dielectric BRDFs in terms of the lobes I&rsquo;ve described so far? The metallic BRDF uses the specular BRDF lobe with the Schlick Fresnel term with the baseColor as R0. The dielectric BRDF is a combination of the Diffuse lobe with the Specular BRDF lobe where the specular BRDF lobe uses the dielectric Fresnel equation. So what we end up with will be the specular part of both the dielectric BRDF and the metallic BRDF being evaluated with one function call and the DisneyFresnel function doing the work of blending between the two based on the <em>metallic</em> and <em>specularTint</em> surface parameters.</p>

<pre><code>//===================================================================================================================
static float3 DisneyFresnel(const SurfaceParameters&amp; surface, const float3&amp; wo, const float3&amp; wm, const float3&amp; wi)
{
    float dotHV = Absf(Dot(wm, wo));

    float3 tint = CalculateTint(surface.baseColor);

    // -- See section 3.1 and 3.2 of the 2015 PBR presentation + the Disney BRDF explorer (which does their
    // -- 2012 remapping rather than the SchlickR0FromRelativeIOR seen here but they mentioned the switch in 3.2).
    float3 R0 = Fresnel::SchlickR0FromRelativeIOR(surface.relativeIOR) * Lerp(float3(1.0f), tint,
                                                                              surface.specularTint);
           R0 = Lerp(R0, surface.baseColor, surface.metallic);

    float dielectricFresnel = Fresnel::Dielectric(dotHV, 1.0f, surface.ior);
    float3 metallicFresnel = Fresnel::Schlick(R0, Dot(wi, wm));

    return Lerp(float3(dielectricFresnel), metallicFresnel, surface.metallic);
}
</code></pre>

<p>Now we have everything to evaluate a single surface interaction.</p>

<pre><code>//===================================================================================================================
float3 EvaluateDisney(const SurfaceParameters&amp; surface, float3 v, float3 l, bool thin,
                      float&amp; forwardPdf, float&amp; reversePdf)
{
    float3 wo = Normalize(MatrixMultiply(v, surface.worldToTangent));
    float3 wi = Normalize(MatrixMultiply(l, surface.worldToTangent));
    float3 wm = Normalize(wo + wi);

    float dotNV = CosTheta(wo);
    float dotNL = CosTheta(wi);

    float3 reflectance = float3::Zero_;
    forwardPdf = 0.0f;
    reversePdf = 0.0f;

    float pBRDF, pDiffuse, pClearcoat, pSpecTrans;
    CalculateLobePdfs(surface, pBRDF, pDiffuse, pClearcoat, pSpecTrans);

    float3 baseColor = surface.baseColor;
    float metallic = surface.metallic;
    float specTrans = surface.specTrans;
    float roughness = surface.roughness;

    // calculate all of the anisotropic params
    float ax, ay;
    CalculateAnisotropicParams(surface.roughness, surface.anisotropic, ax, ay);

    float diffuseWeight = (1.0f - metallic) * (1.0f - specTrans);
    float transWeight   = (1.0f - metallic) * specTrans;

    // -- Clearcoat
    bool upperHemisphere = dotNL &gt; 0.0f &amp;&amp; dotNV &gt; 0.0f;
    if(upperHemisphere &amp;&amp; surface.clearcoat &gt; 0.0f) {
        
        float forwardClearcoatPdfW;
        float reverseClearcoatPdfW;

        float clearcoat = EvaluateDisneyClearcoat(surface.clearcoat, surface.clearcoatGloss, wo, wm, wi,
                                                  forwardClearcoatPdfW, reverseClearcoatPdfW);
        reflectance += float3(clearcoat);
        forwardPdf += pClearcoat * forwardClearcoatPdfW;
        reversePdf += pClearcoat * reverseClearcoatPdfW;
    }

    // -- Diffuse
    if(diffuseWeight &gt; 0.0f) {
        float forwardDiffusePdfW = AbsCosTheta(wi);
        float reverseDiffusePdfW = AbsCosTheta(wo);
        float diffuse = EvaluateDisneyDiffuse(surface, wo, wm, wi, thin);

        float3 sheen = EvaluateSheen(surface, wo, wm, wi);

        reflectance += diffuseWeight * (diffuse * surface.baseColor + sheen);

        forwardPdf += pDiffuse * forwardDiffusePdfW;
        reversePdf += pDiffuse * reverseDiffusePdfW;
    }

    // -- transmission
    if(transWeight &gt; 0.0f) {

        // Scale roughness based on IOR (Burley 2015, Figure 15).
        float rscaled = thin ? ThinTransmissionRoughness(surface.ior, surface.roughness) : surface.roughness;
        float tax, tay;
        CalculateAnisotropicParams(rscaled, surface.anisotropic, tax, tay);

        float3 transmission = EvaluateDisneySpecTransmission(surface, wo, wm, wi, tax, tay, thin);
        reflectance += transWeight * transmission;

        float forwardTransmissivePdfW;
        float reverseTransmissivePdfW;
        Bsdf::GgxVndfAnisotropicPdf(wi, wm, wo, tax, tay, forwardTransmissivePdfW, reverseTransmissivePdfW);

        float dotLH = Dot(wm, wi);
        float dotVH = Dot(wm, wo);
        forwardPdf += pSpecTrans * forwardTransmissivePdfW / (Square(dotLH + surface.relativeIOR * dotVH));
        reversePdf += pSpecTrans * reverseTransmissivePdfW / (Square(dotVH + surface.relativeIOR * dotLH));
    }

    // -- specular
    if(upperHemisphere) {
        float forwardMetallicPdfW;
        float reverseMetallicPdfW;
        float3 specular = EvaluateDisneyBRDF(surface, wo, wm, wi, forwardMetallicPdfW, reverseMetallicPdfW);
        
        reflectance += specular;
        forwardPdf += pBRDF * forwardMetallicPdfW / (4 * AbsDot(wo, wm));
        reversePdf += pBRDF * reverseMetallicPdfW / (4 * AbsDot(wi, wm));
    }

    reflectance = reflectance * Absf(dotNL);

    return reflectance;
}
</code></pre>

<hr />

<h2 id="sampling">Sampling</h2>

<p>Yikes! We&rsquo;re not even done yet. Evaluation of the BRDF is only half the battle; we also need to be able to sample the surface. Before we can start sampling a lobe we first need to start by choosing which lobe to sample. We can skip sheen since its intensity is relatively weak in comparison to the other lobes but that leaves us with clearcoat, specular BRDF, specular BSDF, and diffuse lobes to choose from. None of the Disney papers I&rsquo;ve seen have gone into details about how this was done so I just hacked something together that assigns importance to each lobe that is proportional to the perceived intensity. This is probably bad and will likely change once I start to optimize with the full island rendering.</p>

<pre><code>//===================================================================================================================
static void CalculateLobePdfs(const SurfaceParameters&amp; surface,
                              float&amp; pSpecular, float&amp; pDiffuse, float&amp; pClearcoat, float&amp; pSpecTrans)
{
    float metallicBRDF   = surface.metallic;
    float specularBSDF   = (1.0f - surface.metallic) * surface.specTrans;
    float dielectricBRDF = (1.0f - surface.specTrans) * (1.0f - surface.metallic);

    float specularWeight     = metallicBRDF + dielectricBRDF;
    float transmissionWeight = specularBSDF;
    float diffuseWeight      = dielectricBRDF;
    float clearcoatWeight    = 1.0f * Saturate(surface.clearcoat); 

    float norm = 1.0f / (specularWeight + transmissionWeight + diffuseWeight + clearcoatWeight);

    pSpecular  = specularWeight     * norm;
    pSpecTrans = transmissionWeight * norm;
    pDiffuse   = diffuseWeight      * norm;
    pClearcoat = clearcoatWeight    * norm;
}
</code></pre>

<p>And now sampling is relatively straightforward. <a href="https://schuttejoe.github.io/post/ggximportancesamplingpart2/">I already wrote a blog post about sampling the specular BRDF</a> though some care needs to be taken when using the thin material mode.</p>

<pre><code>//===================================================================================================================
static void SampleDisneySpecTransmission(CSampler* sampler, const SurfaceParameters&amp; surface, float3 v, bool thin,
                                         BsdfSample&amp; sample)
{
    float3 wo = MatrixMultiply(v, surface.worldToTangent);
    if(CosTheta(wo) == 0.0) {
        sample.forwardPdfW = 0.0f;
        sample.reversePdfW = 0.0f;
        sample.reflectance = float3::Zero_;
        sample.wi = float3::Zero_;
        return false;
    }

    // -- Scale roughness based on IOR
    float rscaled = thin ? ThinTransmissionRoughness(surface.ior, surface.roughness) : surface.roughness;
     
    float tax, tay;
    CalculateAnisotropicParams(rscaled, surface.anisotropic, tax, tay);
    
    // -- Sample visible distribution of normals
    float r0 = sampler-&gt;UniformFloat();
    float r1 = sampler-&gt;UniformFloat();
    float3 wm = Bsdf::SampleGgxVndfAnisotropic(wo, tax, tay, r0, r1);

    float dotVH = Dot(wo, wm);
    if(wm.y &lt; 0.0f) {
        dotVH = -dotVH;
    }

    float ni = wo.y &gt; 0.0f ? 1.0f : surface.ior;
    float nt = wo.y &gt; 0.0f ? surface.ior : 1.0f;
    float relativeIOR = ni / nt;

    // -- Disney uses the full dielectric Fresnel equation for transmission. We also importance sample F
    // -- to switch between refraction and reflection at glancing angles.
    float F = Fresnel::Dielectric(dotVH, 1.0f, surface.ior);
    
    // -- Since we're sampling the distribution of visible normals the pdf cancels out with a number of other terms.
    // -- We are left with the weight G2(wi, wo, wm) / G1(wi, wm) and since Disney uses a separable masking function
    // -- we get G1(wi, wm) * G1(wo, wm) / G1(wi, wm) = G1(wo, wm) as our weight.
    float G1v = Bsdf::SeparableSmithGGXG1(wo, wm, tax, tay);

    float pdf;

    float3 wi;
    if(sampler-&gt;UniformFloat() &lt;= F) {
        wi = Normalize(Reflect(wm, wo));

        sample.flags = SurfaceEventFlags::eScatterEvent;
        sample.reflectance = G1v * surface.baseColor;

        float jacobian = (4 * AbsDot(wo, wm));
        pdf = F / jacobian;
    }
    else {
        if(thin) {
            // -- When the surface is thin so it refracts into and then out of the surface during this shading event.
            // -- So the ray is just reflected then flipped and we use the sqrt of the surface color.
            wi = Reflect(wm, wo);
            wi.y = -wi.y;
            sample.reflectance = G1v * Sqrt(surface.baseColor);

            // -- Since this is a thin surface we are not ending up inside of a volume so we treat this as a scatter event.
            sample.flags = SurfaceEventFlags::eScatterEvent;
        }
        else {
            if(Transmit(wm, wo, relativeIOR, wi)) {
                sample.flags = SurfaceEventFlags::eTransmissionEvent;
                sample.medium.phaseFunction = dotVH &gt; 0.0f ? MediumPhaseFunction::eIsotropic : MediumPhaseFunction::eVacuum;
                sample.medium.extinction = CalculateExtinction(surface.transmittanceColor, surface.scatterDistance);
            }
            else {
                sample.flags = SurfaceEventFlags::eScatterEvent;
                wi = Reflect(wm, wo);
            }

            sample.reflectance = G1v * surface.baseColor;
        }

        wi = Normalize(wi);
        
        float dotLH = Absf(Dot(wi, wm));
        float jacobian = dotLH / (Square(dotLH + surface.relativeIOR * dotVH));
        pdf = (1.0f - F) / jacobian;
    }

    if(CosTheta(wi) == 0.0f) {
        sample.forwardPdfW = 0.0f;
        sample.reversePdfW = 0.0f;
        sample.reflectance = float3::Zero_;
        sample.wi = float3::Zero_;
        return false;
    }

    if(surface.roughness &lt; 0.01f) {
        // -- This is a hack to allow us to sample the correct IBL texture when a path bounced off a smooth surface.
        sample.flags |= SurfaceEventFlags::eDiracEvent;
    }

    // -- calculate VNDF pdf terms and apply Jacobian and Fresnel sampling adjustments
    Bsdf::GgxVndfAnisotropicPdf(wi, wm, wo, tax, tay, sample.forwardPdfW, sample.reversePdfW);
    sample.forwardPdfW *= pdf;
    sample.reversePdfW *= pdf;

    // -- convert wi back to world space
    sample.wi = Normalize(MatrixMultiply(wi, MatrixTranspose(surface.worldToTangent)));

    return true;
}
</code></pre>

<p>Sampling a cosine weighted hemisphere is sufficient for sampling the diffuse BRDF. We do need to handle Disney&rsquo;s <em>diffTrans</em> parameter for switching between reflection and transmission here so we importance sample that. Additionally, care must be taken to handle thin surfaces.</p>

<pre><code>//===================================================================================================================
static void SampleDisneyDiffuse(CSampler* sampler, const SurfaceParameters&amp; surface, float3 v, bool thin,
                                BsdfSample&amp; sample)
{
    float3 wo = MatrixMultiply(v, surface.worldToTangent);

    float sign = Sign(CosTheta(wo));

    // -- Sample cosine lobe
    float r0 = sampler-&gt;UniformFloat();
    float r1 = sampler-&gt;UniformFloat();
    float3 wi = sign * SampleCosineWeightedHemisphere(r0, r1);
    float3 wm = Normalize(wi + wo);

    float dotNL = CosTheta(wi);
    if(dotNL == 0.0f) {
        sample.forwardPdfW = 0.0f;
        sample.reversePdfW = 0.0f;
        sample.reflectance = float3::Zero_;
        sample.wi = float3::Zero_;
        return false;
    }

    float dotNV = CosTheta(wo);

    float pdf;

    SurfaceEventFlags eventType = SurfaceEventFlags::eScatterEvent;

    float3 color = surface.baseColor;

    float p = sampler-&gt;UniformFloat();
    if(p &lt;= surface.diffTrans) {
        wi = -wi;
        pdf = surface.diffTrans;

        if(thin)
            color = Sqrt(color);
        else {
            eventType = SurfaceEventFlags::eTransmissionEvent;

            sample.medium.phaseFunction = MediumPhaseFunction::eIsotropic;
            sample.medium.extinction = CalculateExtinction(surface.transmittanceColor, surface.scatterDistance);
        }
    }
    else {
        pdf = (1.0f - surface.diffTrans);
    }

    float3 sheen = EvaluateSheen(surface, wo, wm, wi);

    float diffuse = EvaluateDisneyDiffuse(surface, wo, wm, wi, thin);

    Assert_(pdf &gt; 0.0f);
    sample.reflectance = sheen + color * (diffuse / pdf);
    sample.wi = Normalize(MatrixMultiply(wi, MatrixTranspose(surface.worldToTangent)));
    sample.forwardPdfW = Absf(dotNL) * pdf;
    sample.reversePdfW = Absf(dotNV) * pdf;
    sample.flags = eventType;
    return true;
}
</code></pre>

<p>That leaves clearcoat for which Burley gave the equation for sampling the distribution of normals in the 2012 addendum:</p>

<p>$$cos(\theta_h) = \sqrt{\frac{1 - \xi_2}{1 + (\alpha^2 - 1)\xi_2}}$$</p>

<pre><code>//===================================================================================================================
static bool SampleDisneyClearcoat(CSampler* sampler, const SurfaceParameters&amp; surface, const float3&amp; v,
                                  BsdfSample&amp; sample)
{
    float3 wo = Normalize(MatrixMultiply(v, surface.worldToTangent));

    float a = 0.25f;
    float a2 = a * a;

    float r0 = sampler-&gt;UniformFloat();
    float r1 = sampler-&gt;UniformFloat();
    float cosTheta = Sqrtf(Max&lt;float&gt;(0, (1.0f - Powf(a2, 1.0f - r0)) / (1.0f - a2)));
    float sinTheta = Sqrtf(Max&lt;float&gt;(0, 1.0f - cosTheta * cosTheta));
    float phi = TwoPi_ * r1;

    float3 wm = float3(sinTheta * Cosf(phi), cosTheta, sinTheta * Sinf(phi));
    if(Dot(wm, wo) &lt; 0.0f) {
        wm = -wm;
    }

    float3 wi = Reflect(wm, wo);
    if(Dot(wi, wo) &lt; 0.0f) {
        return false;
    }

    float clearcoatWeight = surface.clearcoat;
    float clearcoatGloss = surface.clearcoatGloss;

    float dotNH = CosTheta(wm);
    float dotLH = Dot(wm, wi);
    float absDotNL = Absf(CosTheta(wi));
    float absDotNV = Absf(CosTheta(wo));

    float d = GTR1(Absf(dotNH), Lerp(0.1f, 0.001f, clearcoatGloss));
    float f = Fresnel::Schlick(0.04f, dotLH);
    float g = Bsdf::SeparableSmithGGXG1(wi, 0.25f) * Bsdf::SeparableSmithGGXG1(wo, 0.25f);

    float fPdf = d / (4.0f * Dot(wo, wm));

    sample.reflectance = float3(0.25f * clearcoatWeight * g * f * d) / fPdf;
    sample.wi = Normalize(MatrixMultiply(wi, MatrixTranspose(surface.worldToTangent)));
    sample.forwardPdfW = fPdf;
    sample.reversePdfW = d / (4.0f * Dot(wi, wm));

    return true;
}
</code></pre>

<hr />

<h2 id="subsurface-scattering">Subsurface scattering</h2>

<p>We&rsquo;re so close! From what I can tell you won&rsquo;t even need this for the Moana Island scene since none of the content seems to use it (though maybe the cloud they released does?) but for the sake of completeness I want to handle the &ldquo;integrated subsurface scattering&rdquo; part. Burley described how to calculate the extinction coefficient in an art friendly way in <a href="https://disney-animation.s3.amazonaws.com/uploads/production/publication_asset/153/asset/siggraph2016SSS.pdf"><strong>Practical and Controllable Subsurface Scattering for Production Path Tracing</strong></a>. He also discussed importance sampling there but I know Disney has recently released quite a few improvements for volumetrics (ex: <a href="http://drz.disneyresearch.com/~jnovak/publications/SDTracking/SDTracking.pdf">Spectral and Decomposition Tracking</a>) since this paper was released so there are likely better ways to handle that.</p>

<pre><code>//=============================================================================================================================
static float3 CalculateExtinction(float3 apparantColor, float scatterDistance)
{
    float3 a = apparantColor;
    float3 a2 = a * a;
    float3 a3 = a2 * a;

    float3 alpha = float3(1.0f) - Exp(-5.09406f * a + 2.61188f * a2 - 4.31805f * a3);
    float3 s = float3(1.9f) - a + 3.5f * (a - float3(0.8f)) * (a - float3(0.8f));

    return 1.0f / (s * scatterDistance);
}
</code></pre>

<p>Then with that they mention using isotropic scattering. This post is already absurdly long and I expect I&rsquo;ll be covering volumetrics in much more detail later so for now I recommend reading <a href="https://computergraphics.stackexchange.com/a/5229">this excellent post</a> if you&rsquo;re unfamiliar with path tracing volumetrics.</p>

<hr />

<h2 id="conclusion">Conclusion</h2>

<p>Here are a couple of example materials. Hopefully this is the last programmer art, rendered image I show in the blog until I get to volumetrics :P</p>

<p>From left to right we have:</p>

<ul>
<li>Copper torus</li>
<li>Clearcoat plastic sphere</li>
<li>Specular transmission with isometric subsurface scattering on the large dragon</li>
<li>Rough diffuse small dragon</li>
<li>Thin diffuse transmission on the quad with 2 smaller copper quads behind it.</li>
</ul>

<p><center><img src="/img/Posts/DisneyBsdf/Main.png" alt="" /></center></p>

<hr />

<p>And for some additional pictures from the Moana Island Scene itself here are two of my favorite elements with lighting of questionable quality. I&rsquo;ll note that the reason the lighting is bad is because I have almost no tooling for this and iteration is very slow. I definitely need to add some kind of progressive controls in the future.</p>

<p><center><img src="/img/Posts/DisneyBsdf/GardeniaA.png" alt="" /><br><i>isGardeniaA rendered in my hobby renderer. Clearly the leaves would have subdivision applied to them in Hyperion.</i></center></p>

<p><center><img src="/img/Posts/DisneyBsdf/Hibiscus.png" alt="" /><br><i>isHibiscus rendered in my hobby renderer</i></center></p>

<p>That&rsquo;s a whole lot of content to take in. I&rsquo;m sure I left out a handful of details so feel free to ask any questions on twitter. You can also check out <a href="https://github.com/schuttejoe/Selas/blob/dev/Source/Core/Shading/Disney.cpp">my full implementation</a> or <a href="https://github.com/schuttejoe/Selas">my github</a> if you need additional details.</p>

<p>I hope you found this useful! Please leave any feedback here: <a href="https://twitter.com/schuttejoe"><strong>@schuttejoe</strong></a>!</p>

<hr />

<p>Updates (10/10/2018):</p>

<ul>
<li>Corrected a typo in CalculateExtinction pointed out to me by <a href="https://twitter.com/syoyo">Syoyo Fujita</a></li>
<li>Updated code with much better handling for cases that would lead to NaNs</li>
<li>Corrected some errors in my pdf calculation. I had often failed to take the Jacobian of the transform applied to the sampled direction into account.</li>
<li>Added images of isGardeniaA and isHibiscus</li>
</ul>

<hr />

<p>References:</p>

<ul>
<li><a href="https://www.disneyanimation.com/technology/datasets"><strong>Disney&rsquo;s Moana Island Scene</strong></a></li>
<li><a href="http://blog.selfshadow.com/publications/s2012-shading-course/burley/s2012_pbs_disney_brdf_notes_v3.pdf"><strong>Physically Based Shading at Disney</strong> - Burley 2012</a></li>
<li><a href="http://blog.selfshadow.com/publications/s2015-shading-course/burley/s2015_pbs_disney_bsdf_notes.pdf"><strong>Extending the Disney BRDF to a BSDF with Integrated Subsurface Scattering</strong> - Burley 2015</a></li>
<li><a href="http://blog.selfshadow.com/publications/s2012-shading-course/"><strong>SIGGRAPH 2012 Course: Practical Physically Based Shading in Film and Game Production</strong></a></li>
<li><a href="http://blog.selfshadow.com/publications/s2015-shading-course/"><strong>SIGGRAPH 2015 Course: Physically Based Shading in Theory and Practice</strong></a></li>
<li><a href="https://github.com/wdas/brdf"><strong>Disney BRDF Explorer</strong></a></li>
<li><a href="https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.html"><strong>Microfacet Models for Refraction through Rough Surfaces</strong></a></li>
<li><a href="https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/"><strong>Memo on the Fresnel Equations</strong></a></li>
<li><a href="http://jcgt.org/published/0003/02/03/"><strong>Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs</strong></a></li>
<li><a href="https://disney-animation.s3.amazonaws.com/uploads/production/publication_asset/153/asset/siggraph2016SSS.pdf"><strong>Practical and Controllable Subsurface Scattering for Production Path Tracing</strong></a></li>
</ul>

<p>Additional Thanks:</p>

<ul>
<li><a href="http://casual-effects.com/data/">Morgan McGuire for the cleaned up version of Stanford Graphics Lab&rsquo;s Chinese Dragon model</a></li>
<li><a href="https://cc0textures.com">CC0 Textures for the paper texture</a></li>
<li><a href="https://twitter.com/syoyo">Syoyo Fujita</a> for pointing out a typo in my CalculateExtinction function.</li>
</ul>
</div>

    
    

    

    

</main>

        <footer>

            <p class="copyright text-muted"></p>

        </footer>
       
    </body>

</html>

